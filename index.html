<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GITECH PDF Data Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.js"></script> 
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, setDoc, doc, collection, query, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // NEW: Firebase Storage Imports
        import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";


        // Global Firebase variables
        window.app = null;
        window.db = null;
        window.auth = null;
        window.storage = null; // NEW: Storage variable
        
        // Custom Firebase Config provided by the user
        const CUSTOM_FIREBASE_CONFIG = {
            apiKey: "AIzaSyA_RhnNogN-l45mcrSfKbfipkMYkpfDxrc",
            authDomain: "gitechslip.firebaseapp.com",
            projectId: "gitechslip",
            storageBucket: "gitechslip.appspot.com", // Updated to default storage bucket format
            messagingSenderId: "577549935977",
            appId: "1:577549935977:web:fba329f423a895469049f8",
            measurementId: "G-S11NLH0TYX"
        };

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
   
                const firebaseConfig = typeof __firebase_config !== 'undefined' 
                    ? JSON.parse(__firebase_config) 
                    : CUSTOM_FIREBASE_CONFIG;
                
               
                if (Object.keys(firebaseConfig).length > 0 && firebaseConfig.apiKey) {
                    window.app = initializeApp(firebaseConfig);
                    window.db = getFirestore(window.app);
                    window.auth = getAuth(window.app);
                    window.storage = getStorage(window.app); // NEW: Initialize Storage

                    const initialAuthToken = typeof __initial_auth_token !== 'undefined' 
                        ? __initial_auth_token : null;
                    
                    if (initialAuthToken) {
                        await signInWithCustomToken(window.auth, initialAuthToken);
                        console.log("Firebase signed in with custom token.");
                    } else {
                        await signInAnonymously(window.auth);
                        console.log("Firebase signed in anonymously.");
                    }
                    console.log(`Firestore and Storage initialized. App ID: ${appId}`);
                    
                    await window.fetchSavedDocuments(); 

                } else {
                    console.warn("Firebase configuration not fully available. Proceeding without database storage.");
                }
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                window.showMessage("Failed to initialize database connection. Check console.", true);
            }
        });
        
        // Exporting Firebase functions globally
        window.setDoc = setDoc;
        window.doc = doc;
        window.collection = collection;
        window.query = query;
        window.getDocs = getDocs;
        window.deleteDoc = deleteDoc;
        window.storageRef = storageRef; // NEW: Storage reference helper
        window.uploadBytes = uploadBytes; // NEW: Upload bytes
        window.getDownloadURL = getDownloadURL; // NEW: Get URL
    </script>
    <style>
        /* Custom styles for better aesthetics and loading visibility */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body { font-family: 'Inter', sans-serif; }
        .spinner {
            border-top-color: #EF4444; /* GITECH Red accent */
            -webkit-animation: spin 1s ease-in-out infinite;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .raw-text-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.8rem;
        }

        /* Custom Tailwind colors based on GITECH logo */
        .bg-gitech-red { background-color: #EF4444; }
        .hover\:bg-gitech-red-dark:hover { background-color: #DC2626; }
        .text-gitech-red { color: #EF4444; }
        .border-gitech-red { border-color: #EF4444; }

        .bg-gitech-yellow-light { background-color: #FEF3C7; }
        .text-gitech-black { color: #1A1A1A; }
        
        .focus\:ring-gitech-red:focus { --tw-ring-color: #EF4444; }
        .focus\:border-gitech-red:focus { border-color: #EF4444; }

        /* Sidebar Custom Styles */
        #sidebar {
            transition: transform 0.3s ease-in-out;
            z-index: 50;
        }
        .sidebar-open #sidebar {
            transform: translateX(0);
        }
        .sidebar-closed #sidebar {
            transform: translateX(100%);
        }
        #sidebar-overlay {
            z-index: 40;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">

    <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 hidden" onclick="toggleSidebar()"></div>
    <div id="sidebar" class="fixed top-0 right-0 h-full w-80 bg-white shadow-xl p-4 transform translate-x-full overflow-y-auto">
        
        <div class="flex justify-between items-center pb-4 border-b border-gray-200 sticky top-0 bg-white z-10">
            <h3 class="text-xl font-bold text-gitech-red">Saved Documents</h3>
            <button onclick="toggleSidebar()" class="text-gray-500 hover:text-gray-800 transition">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        </div>

        <div class="mt-4 sticky top-16 bg-white z-10 py-2">
            <input type="text" id="client-search" onkeyup="filterSavedDocuments()" placeholder="Search by Client Account or Name" 
                   class="w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-gitech-red focus:border-gitech-red text-sm">
        </div>
        
        <ul id="saved-document-list" class="mt-4 space-y-3">
            <li id="sidebar-loading" class="text-gray-500 text-sm">Loading saved files...</li>
            </ul>
        <p id="sidebar-no-results" class="text-gray-500 text-sm mt-4 hidden">No matching documents found.</p>

    </div>
    <div id="main-content" class="relative transition-all duration-300 ease-in-out">
        <div class="max-w-4xl mx-auto p-4 md:p-8">
            <header class="text-center mb-10 relative">
                <h1 class="text-4xl font-extrabold text-gitech-black">GITECH PDF Data Extractor</h1>
                <div id="message-box" class="mt-4 p-3 bg-red-100 text-red-700 rounded-lg hidden"></div>
                
                <button onclick="toggleSidebar()" class="absolute top-0 right-0 bg-gitech-red text-white p-2 rounded-full shadow-lg hover:bg-gitech-red-dark transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                </button>
            </header>

            <div class="bg-white p-6 rounded-xl shadow-lg mb-8 border border-gitech-red">
                <label for="pdf-upload" class="block text-lg font-medium text-gray-700 mb-3">Upload PDF Files</label>
                <div class="flex items-center space-x-4">
                    <input type="file" id="pdf-upload" multiple accept=".pdf" 
                           class="flex-grow w-full text-sm text-gray-500
                           file:mr-4 file:py-2 file:px-4
                                    file:rounded-full file:border-0
                                    file:text-sm file:font-semibold
                           file:bg-gitech-yellow-light file:text-gitech-black
                                    hover:file:bg-yellow-100 cursor-pointer"
                           onchange="handleFileSelect(event)">
                    <button onclick="clearFiles()" class="bg-gray-200 text-gray-700 py-2 px-4 rounded-lg text-sm font-medium hover:bg-gray-300 transition duration-150 whitespace-nowrap">Clear</button>
                </div>
                <p class="text-xs text-gray-500 mt-2">Select one or multiple scanned PDF files.</p>
            </div>
            
            <div id="loading-indicator" class="hidden text-center p-6 bg-yellow-50 rounded-xl shadow-md">
                <div class="spinner border-4 border-solid border-gray-200 h-10 w-10 rounded-full mx-auto mb-3"></div>
                <p class="text-lg font-medium text-gitech-black">Sending image to Gemini for advanced data extraction... Please wait.</p>
            </div>

            <div id="results-container" class="space-y-8 mt-10">
                <p class="text-center text-gray-500 p-8 border border-dashed rounded-lg">Upload a PDF to begin extraction.</p>
            </div>

            <canvas id="pdf-canvas" class="hidden"></canvas>
        </div>
    </div>


    <script>
        // =========================================================================
        // API Configuration (FIXED SCOPE AND KEY)
        // =========================================================================
        
        const apiKey = 'AIzaSyD96luWwd2cNjPiAAqlkrJ_4dLI8E_kLWk';
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // =========================================================================
        // END API Configuration
        // =========================================================================

        let extractionResults = [];
        let savedDocumentsCache = []; 
        const loadingIndicator = document.getElementById('loading-indicator');
        const resultsContainer = document.getElementById('results-container');
        const messageBox = document.getElementById('message-box');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const sidebarList = document.getElementById('saved-document-list');
        const sidebarLoading = document.getElementById('sidebar-loading');
        const sidebarNoResults = document.getElementById('sidebar-no-results');


        // Set PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // --- UI/Sidebar Functions ---

        /**
         * Toggles the sidebar open and closed.
         */
        window.toggleSidebar = function() {
            const isOpen = sidebar.classList.contains('translate-x-full');
            
            if (isOpen) {
                // Open the sidebar
                sidebar.classList.remove('translate-x-full');
                sidebarOverlay.classList.remove('hidden');
            } else {
                // Close the sidebar
                sidebar.classList.add('translate-x-full');
                sidebarOverlay.classList.add('hidden');
            }
        }
        
        /**
         * Fetches saved documents from Firestore.
         */
        window.fetchSavedDocuments = async function() {
            if (!window.db || !window.auth.currentUser) {
                sidebarLoading.textContent = "Sign in required to view saved data.";
                return [];
            }

            const userId = window.auth.currentUser.uid;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            
            sidebarLoading.classList.remove('hidden');
            sidebarList.innerHTML = ''; // Clear previous list

            try {
                // Path: /artifacts/{appId}/users/{userId}/client_data/
                const path = `artifacts/${appId}/users/${userId}/client_data`;
                const q = window.query(window.collection(window.db, path));
                const querySnapshot = await window.getDocs(q);
                
                savedDocumentsCache = [];
                querySnapshot.forEach((doc) => {
                    savedDocumentsCache.push({ id: doc.id, ...doc.data() });
                });
                
                window.renderSidebar(savedDocumentsCache);
                return savedDocumentsCache;
            } catch (e) {
                console.error("Error fetching documents:", e);
                sidebarLoading.textContent = "Error loading saved files.";
                return [];
            } finally {
                sidebarLoading.classList.add('hidden');
            }
        }

        /**
         * Renders the list of documents in the sidebar including CRUD buttons.
         */
        window.renderSidebar = function(documents) {
            sidebarList.innerHTML = '';
            sidebarNoResults.classList.add('hidden');

            if (documents.length === 0) {
                sidebarList.innerHTML = '<li class="text-gray-500 text-sm">No documents saved yet.</li>';
                return;
            }

            documents.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            documents.forEach(doc => {
                const li = document.createElement('li');
                li.className = 'p-3 bg-gray-100 rounded-lg border border-gray-200 hover:bg-gray-200 transition duration-150';
                li.innerHTML = `
                    <p class="font-semibold text-sm text-gitech-black">${doc.clientAccount.replace(/_/g, '/')}</p>
                    <p class="text-xs text-gray-600 truncate">Client: ${doc.clientName}</p>
                    <p class="text-xs text-gray-500 mb-2">Date: ${doc.dateOfSlip || 'N/A'}</p>
                    <div class="flex space-x-2 mt-2">
                        <button onclick="window.viewSavedDocument('${doc.id}')" 
                                class="flex-1 py-1 text-xs text-white bg-green-600 rounded hover:bg-green-700 transition">View/Export</button>
                        <button onclick="window.editSavedDocument('${doc.id}')" 
                                class="flex-1 py-1 text-xs text-white bg-blue-600 rounded hover:bg-blue-700 transition">Edit</button>
                        <button onclick="window.deleteSavedDocument('${doc.id}')" 
                                class="flex-1 py-1 text-xs text-white bg-red-600 rounded hover:bg-red-700 transition">Delete</button>
                    </div>
                `;
                li.setAttribute('data-search', `${doc.clientAccount} ${doc.clientName} ${doc.projectNumber}`.toLowerCase());
                
                sidebarList.appendChild(li);
            });
        }

        /**
         * Filters the rendered list based on search input.
         */
        window.filterSavedDocuments = function() {
            const filter = document.getElementById('client-search').value.toLowerCase();
            const listItems = sidebarList.getElementsByTagName('li');
            let foundCount = 0;

            for (let i = 0; i < listItems.length; i++) {
                const li = listItems[i];
                if (li.id === 'sidebar-loading' || li.textContent.includes('No documents saved')) continue; 
                
                const searchValue = li.getAttribute('data-search');

                if (searchValue && searchValue.includes(filter)) {
                    li.style.display = "";
                    foundCount++;
                } else {
                    li.style.display = "none";
                }
            }
            
            if (foundCount === 0 && listItems.length > 0 && !sidebarLoading.classList.contains('hidden')) {
                sidebarNoResults.classList.remove('hidden');
            } else {
                sidebarNoResults.classList.add('hidden');
            }
        }
        
        /**
         * Deletes a document from Firestore and refreshes the sidebar.
         */
        window.deleteSavedDocument = async function(docId) {
            if (!confirm(`Are you sure you want to delete the saved document with account ID: ${docId.replace(/_/g, '/')}`)) {
                return;
            }

            if (!window.db || !window.auth.currentUser) {
                showMessage("Database not initialized or user not signed in.", true);
                return;
            }

            const userId = window.auth.currentUser.uid;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const docRef = window.doc(window.db, `artifacts/${appId}/users/${userId}/client_data`, docId);
            
            try {
                // NOTE: A more complete solution would also delete the PDF file from Firebase Storage here.
                await window.deleteDoc(docRef);
                showMessage(`Document ${docId.replace(/_/g, '/')} deleted successfully.`, false);
                await window.fetchSavedDocuments(); // Refresh list
                window.clearEditForm(); // Clear the main area if this document was being edited
            } catch (e) {
                console.error("Error deleting document:", e);
                showMessage(`Failed to delete document: ${e.message}`, true);
            }
        }
        
        /**
         * UPDATED: Opens the saved Merged PDF URL in a new window.
         */
        window.viewSavedDocument = function(docId) {
            const documentData = savedDocumentsCache.find(doc => doc.id === docId);
            if (!documentData) {
                showMessage("Document data not found in cache.", true);
                return;
            }
            
            const pdfUrl = documentData.mergedPdfUrl;
            if (!pdfUrl) {
                showMessage("No merged PDF file found for this entry. It may be an older entry.", true);
                return;
            }
            
            // Open the stored PDF file in a new tab
            window.open(pdfUrl, '_blank');
            showMessage(`Opening saved Merged PDF for ${documentData.clientAccount.replace(/_/g, '/')}.`, false);
        }
        
        /**
         * Fetches document data and opens the edit form.
         */
        window.editSavedDocument = function(docId) {
            const documentData = savedDocumentsCache.find(doc => doc.id === docId);
            if (!documentData) {
                showMessage("Document data not found in cache. Try refreshing the sidebar.", true);
                return;
            }
            window.renderEditForm(documentData);
        }

        /**
         * Renders an editable form in the main content area for a saved document.
         */
        window.renderEditForm = function(data) {
            resultsContainer.innerHTML = '';
            
            const card = document.createElement('div');
            card.className = 'bg-white p-6 rounded-xl shadow-lg border-t-4 border-blue-600'; // Use blue for editing

            card.innerHTML = 
            `
                <h2 class="text-xl font-extrabold text-blue-600 mb-4">
                    Editing Saved Document: ${data.clientAccount.replace(/_/g, '/')}
                </h2>
                <p class="text-sm text-gray-500 mb-6">Original File: ${data.fileName} | Saved: ${new Date(data.timestamp).toLocaleString()}</p>
                
                <div class="space-y-6">
                    <form id="edit-form-${data.id}" class="space-y-4">
                        <input type="hidden" name="docId" value="${data.id}">
                        <input type="hidden" name="originalFileName" value="${data.fileName}">
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Date Of Slip</label>
                            <input type="text" name="dateOfSlip" value="${data.dateOfSlip || 'Not Found'}" required
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-blue-600 focus:border-blue-600">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Client Name</label>
                            <input type="text" name="clientName" value="${data.clientName || 'Not Found'}" required
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-blue-600 focus:border-blue-600">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Project Number</label>
                            <input type="text" name="projectNumber" value="${data.projectNumber || 'Not Found'}" required
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-blue-600 focus:border-blue-600">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700">Client Account</label>
                            <input type="text" name="clientAccount" value="${data.clientAccount || 'Not Found'}" required
                                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-blue-600 focus:border-blue-600">
                        </div>
            
                        <p class="text-sm text-orange-600 bg-orange-50 p-2 rounded">
                            Note: Editing the Client Account will delete the old document and PDF and create a new one, breaking the link to the original file if not present in the upload list.
                        </p>
                        
                        <button type="button"
                                onclick="updateSavedDocument('${data.id}')"
                                class="w-full py-2 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 
                            focus:ring-offset-2 focus:ring-blue-600 transition duration-150 ease-in-out">
                            Update Data (Requires original file re-upload to update PDF)
                        </button>

                        <button type="button"
                                onclick="clearEditForm()"
                                class="w-full py-2 px-4 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 
                            focus:ring-offset-2 focus:ring-gray-300 transition duration-150 ease-in-out">
                            Cancel
                        </button>
                    </form>
                </div>
            `;
            resultsContainer.appendChild(card);
            window.toggleSidebar(); // Close sidebar after opening edit form
        }

        /**
         * Handles the save logic for the edit form.
         * NOTE: Since editing requires re-uploading and merging the PDF, the user would ideally
         * re-run the extraction process for a cleaner update, but for basic field updates, 
         * we only update the Firestore metadata here. Re-uploading the PDF is too complex for an edit form.
         */
        window.updateSavedDocument = async function(originalDocId) {
            const form = document.getElementById(`edit-form-${originalDocId}`);
            if (!form) return;
            
            const updatedData = {
                dateOfSlip: form.elements['dateOfSlip'].value.trim(),
                clientName: form.elements['clientName'].value.trim(),
                projectNumber: form.elements['projectNumber'].value.trim(),
                clientAccount: form.elements['clientAccount'].value.trim(),
            };
            const originalFileName = form.elements['originalFileName'].value.trim();
            const documentData = savedDocumentsCache.find(doc => doc.id === originalDocId);

            if (updatedData.clientAccount === 'Not Found' || updatedData.clientAccount === '') {
                 showMessage("Client Account number is required to save data to the database. Please enter a valid account number.", true);
                return;
            }
            
            const newDocId = updatedData.clientAccount.replace(/\//g, '_'); 

            try {
                // 1. If primary key changed, delete old Firestore document and remove Storage link
                if (originalDocId !== newDocId) {
                    await window.deleteSavedDocument(originalDocId); // This deletes the Firestore entry
                }

                // 2. Simple metadata update (PDF URL remains the same, if it exists)
                const dataToSave = {
                    fileName: originalFileName,
                    timestamp: new Date().toISOString(),
                    mergedPdfUrl: documentData.mergedPdfUrl, // Preserve old URL
                    ...updatedData
                };
            
                const userId = window.auth.currentUser?.uid || 'anonymous';
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                
                const docRef = window.doc(
                    window.db, 
                    `artifacts/${appId}/users/${userId}/client_data`, 
                    newDocId
                );
                await window.setDoc(docRef, dataToSave, { merge: true }); // Save to new ID if changed, or overwrite old if not

                await window.fetchSavedDocuments(); // Refresh list
                
                showMessage(`Document ${newDocId.replace(/_/g, '/')} updated successfully. NOTE: The saved PDF file in the storage list has NOT been updated.`, false);
                window.clearEditForm();

            } catch (error) {
                console.error("Error updating document:", error);
                showMessage(`Failed to update document: ${error.message}`, true);
            }
        }
        
        /**
         * Clears the edit form section and resets the results container.
         */
        window.clearEditForm = function() {
            resultsContainer.innerHTML = '<p class="text-center text-gray-500 p-8 border border-dashed rounded-lg">Upload a PDF to begin extraction.</p>';
        }


        // --- Core Functions for PDF/Firebase ---

        /**
         * Helper function to fetch the original PDF file as an ArrayBuffer.
         */
        window.fetchOriginalPdfFile = async function(fileName) {
            const files = document.getElementById('pdf-upload').files;
            const file = Array.from(files).find(f => f.name === fileName);

            if (!file) {
                throw new Error(`Original file '${fileName}' not found in upload list. Please re-upload the original file.`);
            }

            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        /**
         * NEW HELPER: Generates the Merged PDF bytes and final filename.
         */
        window.generateMergedPdfBytes = async function(editedData, result) {
            const PDFLib = window.PDFLib;
            if (!PDFLib || !PDFLib.PDFDocument) {
                throw new Error("PDF merging library not loaded. (window.PDFLib is unavailable)");
            }
            const PDFDocument = PDFLib.PDFDocument;
            
            // 1. Generate the Data PDF (The page containing the extracted text)
            const { jsPDF } = window.jspdf;
            const dataPdf = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });

            const pdfWidth = dataPdf.internal.pageSize.getWidth();
            const pdfHeight = dataPdf.internal.pageSize.getHeight();
            const margin = 10;
            const lineHeight = 7;
            let currentY = margin;
            
            // Add the Original Image Preview (First 50% height)
            const imgData = result.originalImageBase64;
            const imgProps = dataPdf.getImageProperties(imgData);
            const imgWidth = pdfWidth - 2 * margin;
            const effectiveImgHeight = pdfHeight / 2.5;
            dataPdf.addImage(imgData, 'JPEG', margin, currentY, imgWidth, effectiveImgHeight);
            currentY += effectiveImgHeight + 5;
            
            // Add Extracted/Edited Text
            dataPdf.setFontSize(18);
            dataPdf.setTextColor(26, 26, 26);
            dataPdf.text('Extracted & Edited Slip Data', margin, currentY);
            currentY += lineHeight * 2;
            
            dataPdf.setFontSize(12);
            dataPdf.setTextColor(0, 0, 0);
            
            // Populate fields in the data PDF
            ['Date Of Slip', 'Client Name', 'Project Number', 'Client Account'].forEach(label => {
                const keyMap = {
                    'Date Of Slip': 'dateOfSlip',
                    'Client Name': 'clientName',
                    'Project Number': 'projectNumber',
                    'Client Account': 'clientAccount'
                };
                const key = keyMap[label];
                
                dataPdf.setFont('helvetica', 'bold');
                dataPdf.text(`${label}:`, margin, currentY);
                dataPdf.setFont('helvetica', 'normal');
                dataPdf.text(editedData[key], margin + 40, currentY);
                currentY += lineHeight;
            });
            const dataPdfBytes = dataPdf.output('arraybuffer');
            
            // 2. Fetch Original PDF and Merge (Merging Step)
            const originalPdfBuffer = await window.fetchOriginalPdfFile(result.fileName);
            const originalDoc = await PDFDocument.load(originalPdfBuffer);
            const dataDoc = await PDFDocument.load(dataPdfBytes);
            
            // Copy all pages from the new data PDF to the end of the original PDF
            const copiedPages = await originalDoc.copyPages(dataDoc, dataDoc.getPageIndices());
            copiedPages.forEach(page => originalDoc.addPage(page));

            // 3. Save the Merged Document
            const mergedPdfBytes = await originalDoc.save();
            
            // 4. Normalize filename
            const safeDate = editedData.dateOfSlip.replace(/[^a-zA-Z0-9]/g, '').substring(0, 8);
            const safeClient = editedData.clientName.replace(/[^a-zA-Z0-9\s]/g, '').substring(0, 20).trim().replace(/\s/g, '_');
            const safeProject = editedData.projectNumber.replace(/[^a-zA-Z0-9\s]/g, '').trim().replace(/\s/g, '_');
            const safeAccount = editedData.clientAccount.replace(/\//g, '_');
            const fileName = `${safeDate}-${safeClient}-${safeProject}-${safeAccount}.pdf`;

            return { mergedPdfBytes, fileName };
        }

        /**
         * NEW HELPER: Uploads PDF bytes to Firebase Storage and returns the download URL.
         */
        window.uploadPdfToStorage = async function(pdfBytes, fileName, clientAccount) {
            if (!window.storage) {
                throw new Error("Firebase Storage not initialized.");
            }
            
            const userId = window.auth.currentUser?.uid || 'anonymous';
            const storagePath = `users/${userId}/merged_pdfs/${clientAccount.replace(/\//g, '_')}/${fileName}`;
            const fileRef = window.storageRef(window.storage, storagePath);
            
            // Upload the file
            const uploadTask = await window.uploadBytes(fileRef, pdfBytes, {
                contentType: 'application/pdf'
            });
            
            // Get the download URL
            const downloadUrl = await window.getDownloadURL(uploadTask.ref);
            return downloadUrl;
        }

        /**
         * Saves the extracted data AND the PDF URL to the Firestore database.
         */
        window.saveDataAndUrlToFirestore = async function(editedData, fileName, mergedPdfUrl) {
            if (!window.db || !window.auth.currentUser) {
                throw new Error("Database connection not available or user not signed in.");
            }
            
            const docId = editedData.clientAccount.replace(/\//g, '_'); 
            
            const dataToSave = {
                fileName: fileName,
                timestamp: new Date().toISOString(),
                mergedPdfUrl: mergedPdfUrl, // NEW: Save the public URL
                ...editedData
            };
            
            const userId = window.auth.currentUser.uid;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            
            try {
                const docRef = window.doc(
                    window.db, 
                    `artifacts/${appId}/users/${userId}/client_data`, 
                    docId
                );
                await window.setDoc(docRef, dataToSave, { merge: true });
                
                await window.fetchSavedDocuments(); // Refresh sidebar after successful save/update
                
                console.log(`Document successfully written to client_data/${docId}.`);
            } catch (e) {
                console.error("Error writing document to Firestore:", e);
                throw new Error("Failed to save data to database.");
            }
        }
        
        /**
         * Utility to display temporary messages/errors.
         */
        function showMessage(text, isError = false) {
            messageBox.textContent = text;
            messageBox.classList.remove('hidden', 'bg-red-100', 'bg-green-100', 'text-red-700', 'text-green-700');
            messageBox.classList.add(isError ? 'bg-red-100' : 'bg-green-100', isError ? 'text-red-700' : 'text-green-700');
            setTimeout(() => {
                messageBox.classList.add('hidden');
            }, 8000);
        }

        /**
         * Function to clear the files and the results.
         */
        window.clearFiles = function() {
            const pdfFileInput = document.getElementById('pdf-upload');
            if (pdfFileInput) {
                pdfFileInput.value = ''; 
            }
            
            extractionResults = [];
            loadingIndicator.classList.add('hidden');
            resultsContainer.innerHTML = '<p class="text-center text-gray-500 p-8 border border-dashed rounded-lg">Upload a PDF to begin extraction.</p>';
            messageBox.classList.add('hidden');
            messageBox.textContent = '';
            console.log("Files and results cleared.");
        }
        
        /**
         * Step 1: Handle file selection and start processing.
         */
        window.handleFileSelect = async function(event) {
            if (apiKey === '' || apiKey === 'YOUR_API_KEY_HERE') {
                showMessage("CRITICAL ERROR: API Key is missing. Please insert your Gemini API Key into the 'apiKey' variable in the code.", true);
                return;
            }
            
            const files = event.target.files;
            if (files.length === 0) return;

            extractionResults = [];
            resultsContainer.innerHTML = '';
            
            const filePromises = Array.from(files).map(file => processFileForGemini(file));
            try {
                loadingIndicator.classList.remove('hidden');
                const results = [];
                for (const filePromise of filePromises) {
                    const result = await filePromise;
                    if (result) {
                        results.push(result);
                    }
                }

                extractionResults = results;
                renderResults();
                
                if (extractionResults.length > 0) {
                    showMessage(`Successfully processed ${extractionResults.length} file(s) using Gemini AI.`, false);
                } else {
                    showMessage("Processing finished, but 0 documents were successfully extracted. Check console for PDF rendering or API errors.", true);
                }

            } catch (error) {
                console.error("Error during file processing:", error);
                showMessage("A critical error occurred during processing. Check console for details.", true);
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        /**
         * Converts a Base64 string into its raw data (excluding the mime type header).
         */
        function base64ToData(base64) {
            const commaIndex = base64.indexOf(',');
            return commaIndex !== -1 ? base64.substring(commaIndex + 1) : base64;
        }

        /**
         * Step 2: Load PDF, convert to image, and call Gemini for extraction.
         */
        async function processFileForGemini(file) {
            const fileReader = new FileReader();
            return new Promise((resolve) => {
                fileReader.onload = async () => {
                    try {
                        const arrayBuffer = fileReader.result;
                        
                        // --- 1. PDF Loading ---
                        let pdfDocument;
                        try {
                            pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                        } catch (e) {
                            console.error(`[ERROR] PDF.js failed to load document ${file.name}:`, e);
                            showMessage(`Failed to load PDF: ${file.name}. It might be corrupted or password-protected.`, true);
                            return resolve(null);
                        }
                        
                        // --- 2. Page Rendering ---
                        let page;
                        try {
                            page = await pdfDocument.getPage(1);
                        } catch (e) {
                            console.error(`[ERROR] PDF.js failed to get page 1 of ${file.name}:`, e);
                            showMessage(`Failed to get Page 1 from ${file.name}.`, true);
                            return resolve(null);
                        }

                        // Render PDF page to canvas at high resolution
                        const canvas = document.getElementById('pdf-canvas');
                        const viewport = page.getViewport({ scale: 3.0 }); 
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        
                        const renderContext = {
                            canvasContext: canvas.getContext('2d'),
                            viewport: viewport
                        };
                        try {
                            await page.render(renderContext).promise;
                        } catch (e) {
                            console.error(`[ERROR] PDF.js failed to render page of ${file.name}:`, e);
                            showMessage(`Failed to render image for ${file.name}. Ensure PDF content is simple.`, true);
                            return resolve(null);
                        }
                        
                        // Get original image data (Base64) for API and PDF inclusion
                        const originalImageBase64 = canvas.toDataURL('image/jpeg', 0.9);
                        const mimeType = 'image/jpeg';
                        const imageData = base64ToData(originalImageBase64);
                        
                        // --- 3. Gemini API Call ---
                        const extractedFields = await getExtractedDataFromGemini(imageData, mimeType);
                        // Prepare the data structure
                        const extractedText = JSON.stringify(extractedFields, null, 2);
                        resolve({
                            id: Date.now() + Math.random(), 
                            fileName: file.name,
                            originalImageBase64: originalImageBase64,
                            fields: extractedFields,
                            extractedText: `<pre>${extractedText}</pre>` 
                        });
                    } catch (error) {
                        console.error(`[CRITICAL ERROR] Failed to process file ${file.name}:`, error);
                        showMessage(`Critical error during processing of ${file.name}: ${error.message}`, true);
                        resolve(null); 
                    }
                };
                fileReader.readAsArrayBuffer(file);
            });
        }
        
        /**
         * Step 3: Call the Gemini API to extract structured data from the image.
         */
        async function getExtractedDataFromGemini(imageData, mimeType, maxRetries = 5) {
            
            const systemPrompt = `You are a highly specialized document data extraction system.
                Your task is to precisely locate and extract the following four fields from the provided scanned document, which may contain both printed and handwritten text:
                1. Date Of Slip (Find the date of issue or similar relevant date on the slip.)
                2. Client Name (Find the name of the client or recipient.)
                3. Project Number (Find the specific identifier for the project.)
                4. Client Account (Find the client's account number or reference number.)

                Return ONLY a single JSON object with these exact keys: "dateOfSlip", "clientName", "projectNumber", and "clientAccount".
                If a field cannot be found, use the value "Not Found".
                Be concise and do not include any explanatory text outside of the JSON block.`;
            const userQuery = "Extract the four required fields from this document. Be sure to return only JSON.";
            const payload = {
                contents: [{
                    role: "user",
                    parts: [
                        { text: userQuery },
                        { inlineData: { mimeType: mimeType, data: imageData } }
                    ]
                }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "dateOfSlip": { "type": "STRING", "description": "The extracted date." },
                            "clientName": { "type": "STRING", "description": "The extracted client name." },
                            "projectNumber": { "type": "STRING", "description": "The extracted project number." },
                            "clientAccount": { "type": "STRING", "description": "The extracted client account number." }
                        },
                        required: ["dateOfSlip", "clientName", "projectNumber", "clientAccount"]
                    }
                },
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                }
            };
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(GEMINI_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        if (response.status === 429 && attempt < maxRetries - 1) {
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                            console.warn(`Rate limit hit (429). Retrying in ${Math.round(delay / 1000)}s...`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`HTTP error! status: ${response.status} on attempt ${attempt + 1}`);
                    }

                    const result = await response.json();
                    const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (jsonText) {
                        try {
                            return JSON.parse(jsonText);
                        } catch (e) {
                            console.error("Failed to parse JSON from Gemini response:", jsonText);
                            throw new Error("Invalid JSON structure received from model.");
                        }
                    } else {
                        throw new Error("No text content found in Gemini response.");
                    }
                } catch (error) {
                    if (attempt === maxRetries - 1) {
                        console.error("Gemini API call failed after all retries:", error);
                        throw new Error("Failed to extract data via API.");
                    }
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    console.warn(`Attempt ${attempt + 1} failed. Retrying in ${Math.round(delay / 1000)}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw new Error("Exhausted all API retries.");
        }

        /**
         * Function to toggle the visibility of the raw OCR text (now the structured JSON).
         */
        window.toggleRawText = function(id) {
            const element = document.getElementById(`raw-text-${id}`);
            const button = document.getElementById(`toggle-btn-${id}`);
            if (element.classList.contains('hidden')) {
                element.classList.remove('hidden');
                button.textContent = 'Hide Extracted JSON';
            } else {
                element.classList.add('hidden');
                button.textContent = 'Show Extracted JSON for Debugging';
            }
        }

        /**
         * Step 4: Render the editable results form for new extractions.
         */
        function renderResults() {
            resultsContainer.innerHTML = '';
            if (extractionResults.length === 0) {
                resultsContainer.innerHTML = '<p class="text-center text-gray-500 p-8 border border-dashed rounded-lg">Upload a PDF to begin extraction.</p>';
                return;
            }

            extractionResults.forEach((result, index) => {
                const card = document.createElement('div');
                card.className = 'bg-white p-6 rounded-xl shadow-lg border-t-4 border-gitech-red';
                
                // Get display values
                const dateDisplay = result.fields.dateOfSlip || 'Not Found';
                const clientDisplay = result.fields.clientName || 'Not Found';
                const projectDisplay = result.fields.projectNumber || 'Not Found';
                const accountDisplay = result.fields.clientAccount || 'Not Found'; 

                card.innerHTML = 
                `
                    <h2 class="text-xl font-semibold text-gitech-black mb-4 truncate" title="${result.fileName}">
                        Result ${index + 1}: ${result.fileName}
                    </h2>
                    
                    <div class="mb-6">
                        <p class="text-sm font-medium text-gray-700 mb-2">Original Document Preview (Approx. 50% Height)</p>
                        
                        <div class="relative w-full h-96 border rounded-lg overflow-hidden shadow-md">
                            <img src="${result.originalImageBase64}" alt="Original PDF Scan"
                                class="w-full h-auto object-cover object-[50%_0%]">
                        </div>
                    </div>
                    
                    <div class="space-y-6">
                        <form id="form-${result.id}" class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Date Of Slip</label>
                                <input type="text" name="dateOfSlip" value="${dateDisplay}" required
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-gitech-red focus:border-gitech-red">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Client Name</label>
                                <input type="text" name="clientName" value="${clientDisplay}" required
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-gitech-red 
                                focus:border-gitech-red">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Project Number</label>
                                <input type="text" name="projectNumber" value="${projectDisplay}" required
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-gitech-red focus:border-gitech-red">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700">Client Account</label>
                                <input type="text" name="clientAccount" value="${accountDisplay}" required
                                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 border focus:ring-gitech-red focus:border-gitech-red">
                            </div>
                
                            <div class="flex space-x-4">
                                <button type="button"
                                        onclick="saveDataToList('${result.id}')"
                                        class="flex-1 py-2 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-green-600 hover:bg-green-700 focus:outline-none focus:ring-2 
                                    focus:ring-offset-2 focus:ring-green-600 transition duration-150 ease-in-out">
                                    Save Merged PDF & Data to List
                                </button>

                                <button type="button"
                                        onclick="exportMergedPdf('${result.id}')"
                                        class="flex-1 py-2 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-gitech-red hover:bg-gitech-red-dark focus:outline-none focus:ring-2 
                                    focus:ring-offset-2 focus:ring-gitech-red transition duration-150 ease-in-out">
                                    Export Merged PDF to PC
                                </button>
                            </div>

                        </form>
        
                    </div>
                    
                    <div class="mt-6 pt-4 border-t border-gray-200">
                        <button id="toggle-btn-${result.id}" 
                            onclick="toggleRawText('${result.id}')"
                                class="text-xs text-gitech-red hover:text-red-800 font-medium transition duration-150">
                            Show Extracted JSON for Debugging
                        </button>
                        <div id="raw-text-${result.id}" class="hidden mt-2 p-3 bg-gray-50 border rounded-md raw-text-content text-gray-800">
                            ${result.extractedText.trim()}
                        </div>
        
                    </div>
                `;
                resultsContainer.appendChild(card);
            });
        }


        /**
         * UPDATED: Generates the Merged PDF, uploads it to Storage, and saves the data+URL to Firestore.
         */
        window.saveDataToList = async function(resultId) {
            const result = extractionResults.find(r => r.id.toString() === resultId);
            const form = document.getElementById(`form-${resultId}`);
            if (!result || !form) {
                showMessage("Result or form not found.", true);
                return;
            }

            const editedData = {
                dateOfSlip: form.elements['dateOfSlip'].value.trim(),
                clientName: form.elements['clientName'].value.trim(),
                projectNumber: form.elements['projectNumber'].value.trim(),
                clientAccount: form.elements['clientAccount'].value.trim(),
            };
            if (editedData.clientAccount === 'Not Found' || editedData.clientAccount === '') {
                 showMessage("Client Account number is required to save data to the database. Please enter a valid account number.", true);
                return;
            }

            try {
                showMessage(`Generating Merged PDF and uploading to Firebase Storage... Please wait.`, false);

                // 1. Generate the Merged PDF bytes and filename
                const { mergedPdfBytes, fileName } = await window.generateMergedPdfBytes(editedData, result);
                
                // 2. Upload the PDF to Firebase Storage
                const mergedPdfUrl = await window.uploadPdfToStorage(mergedPdfBytes, fileName, editedData.clientAccount);

                // 3. Save the data and the new URL to Firestore
                await window.saveDataAndUrlToFirestore(editedData, result.fileName, mergedPdfUrl);
                
                showMessage(`Merged PDF and data successfully saved to the **Saved Documents List** under Client Account: ${editedData.clientAccount}.`, false);
            } catch (error) {
                console.error("Error during save to list:", error);
                showMessage(`Error saving to list: ${error.message}`, true);
            }
        }


        /**
         * Uses the new helper to generate the PDF and exports it to PC.
         */
        window.exportMergedPdf = async function(resultId) {
            
            const result = extractionResults.find(r => r.id.toString() === resultId);
            const form = document.getElementById(`form-${resultId}`);
            if (!result || !form) {
                showMessage("Result or form not found.", true);
                return;
            }

            // Get the edited values from the form
            const editedData = {
                dateOfSlip: form.elements['dateOfSlip'].value.trim(),
                clientName: form.elements['clientName'].value.trim(),
                projectNumber: form.elements['projectNumber'].value.trim(),
                clientAccount: form.elements['clientAccount'].value.trim(),
            };
            if (editedData.clientAccount === 'Not Found' || editedData.clientAccount === '') {
                 showMessage("Client Account number is required to generate the PDF filename. Please enter a valid account number.", true);
                return;
            }

            try {
                showMessage(`Generating merged PDF for export...`, false);
                
                // 1. Generate the Merged PDF bytes and filename
                const { mergedPdfBytes, fileName } = await window.generateMergedPdfBytes(editedData, result);
                
                // 2. Initiate download
                const blob = new Blob([mergedPdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showMessage(`Successfully created and downloaded PDF: ${fileName}`, false);

            } catch (error) {
                console.error("Error during PDF generation or merging:", error);
                showMessage(`Error exporting merged PDF: ${error.message}`, true);
            }
        }
    </script>
</body>
</html>
